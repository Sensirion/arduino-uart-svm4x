/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 0.33.0
 * Product:       svm4x
 * Model-Version: 2.0.3
 */
/*
 * Copyright (c) 2023, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "SensirionUartSvm4x.h"
#include <Arduino.h>

static uint8_t communication_buffer[76] = {0};

SensirionUartSvm4x::SensirionUartSvm4x() {
}

float SensirionUartSvm4x::signalTemperature(int16_t temperatureRaw) {
    float temperature = 0.0;
    temperature = temperatureRaw / 200.0;
    return temperature;
}

float SensirionUartSvm4x::signalHumidity(int16_t humidityRaw) {
    float humidity = 0.0;
    humidity = humidityRaw / 100.0;
    return humidity;
}

float SensirionUartSvm4x::signalVocIndex(int16_t vocIndexRaw) {
    float vocIndex = 0.0;
    vocIndex = vocIndexRaw / 10.0;
    return vocIndex;
}

float SensirionUartSvm4x::signalNoxIndex(int16_t noxIndexRaw) {
    float noxIndex = 0.0;
    noxIndex = noxIndexRaw / 10.0;
    return noxIndex;
}

int16_t SensirionUartSvm4x::readMeasuredValues(float& aHumidity,
                                               float& aTemperature,
                                               float& aVocIndex,
                                               float& aNoxIndex) {
    int16_t humidityRaw = 0;
    int16_t tempRaw = 0;
    int16_t vocIdxRaw = 0;
    int16_t noxIdxRaw = 0;
    int16_t localError = 0;
    localError = readMeasuredValuesAsIntegers(humidityRaw, tempRaw, vocIdxRaw,
                                              noxIdxRaw);
    if (localError != NO_ERROR) {
        return localError;
    }
    aHumidity = signalHumidity(humidityRaw);
    aTemperature = signalTemperature(tempRaw);
    aVocIndex = signalVocIndex(vocIdxRaw);
    aNoxIndex = signalNoxIndex(noxIdxRaw);
    return localError;
}

int16_t
SensirionUartSvm4x::getTemperatureOffsetForRhtMeasurements(float& arg0) {
    int16_t tOffsetInt = 0;
    int16_t localError = 0;
    localError = llgetTemperatureOffsetForRhtMeasurements(tOffsetInt);
    if (localError != NO_ERROR) {
        return localError;
    }
    arg0 = (float)(tOffsetInt / 200);

    return localError;
}

int16_t
SensirionUartSvm4x::setTemperatureOffsetForRhtMeasurements(float tOffset) {
    int16_t tOffsetInt = 0;
    int16_t localError = 0;
    tOffsetInt = (int16_t)((tOffset * 200) + 0.5);
    localError = llsetTemperatureOffsetForRhtMeasurements(tOffsetInt);
    if (localError != NO_ERROR) {
        return localError;
    }
    return localError;
}

int16_t SensirionUartSvm4x::getProductType(int8_t productType[],
                                           uint16_t productTypeSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 76);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 76);
    localError = txFrame.begin(0xd0, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)productType, productTypeSize);
    return localError;
}

int16_t SensirionUartSvm4x::getProductName(int8_t productName[],
                                           uint16_t productNameSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0xd0, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)productName, productNameSize);
    return localError;
}

int16_t SensirionUartSvm4x::getSerialNumber(int8_t serialNumber[],
                                            uint16_t serialNumberSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 76);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 76);
    localError = txFrame.begin(0xd0, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(3);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)serialNumber, serialNumberSize);
    return localError;
}

int16_t
SensirionUartSvm4x::getVersion(uint8_t& firmwareMajor, uint8_t& firmwareMinor,
                               bool& firmwareDebug, uint8_t& hardwareMajor,
                               uint8_t& hardwareMinor, uint8_t& protocolMajor,
                               uint8_t& protocolMinor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 26);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 26);
    localError = txFrame.begin(0xd1, SVM4X_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt8(firmwareMajor);
    localError |= rxFrame.getUInt8(firmwareMinor);
    localError |= rxFrame.getBool(firmwareDebug);
    localError |= rxFrame.getUInt8(hardwareMajor);
    localError |= rxFrame.getUInt8(hardwareMinor);
    localError |= rxFrame.getUInt8(protocolMajor);
    localError |= rxFrame.getUInt8(protocolMinor);
    return localError;
}

int16_t SensirionUartSvm4x::deviceReset() {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0xd3, SVM4X_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    delay(100);
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::getSystemUpTime(uint32_t& systemUpTime) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 20);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 20);
    localError = txFrame.begin(0x93, SVM4X_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getUInt32(systemUpTime);
    return localError;
}

int16_t SensirionUartSvm4x::startMeasurement() {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0x0, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::stopMeasurement() {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0x1, SVM4X_SHDLC_ADDR, 0);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::readMeasuredValuesAsIntegers(int16_t& humidity,
                                                         int16_t& temperature,
                                                         int16_t& vocIndex,
                                                         int16_t& noxIndex) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x3, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(16);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt16(humidity);
    localError |= rxFrame.getInt16(temperature);
    localError |= rxFrame.getInt16(vocIndex);
    localError |= rxFrame.getInt16(noxIndex);
    return localError;
}

int16_t SensirionUartSvm4x::readMeasuredRawValues(int16_t& rawHumidity,
                                                  int16_t& rawTemperature,
                                                  uint16_t& rawVocTicks,
                                                  uint16_t& rawNoxTicks) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x3, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(13);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt16(rawHumidity);
    localError |= rxFrame.getInt16(rawTemperature);
    localError |= rxFrame.getUInt16(rawVocTicks);
    localError |= rxFrame.getUInt16(rawNoxTicks);
    return localError;
}

int16_t
SensirionUartSvm4x::llgetTemperatureOffsetForRhtMeasurements(int16_t& tOffset) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 16);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 16);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(1);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt16(tOffset);
    return localError;
}

int16_t SensirionUartSvm4x::getVocTuningParameters(
    int16_t& vocIndexOffset, int16_t& learningTimeOffsetHours,
    int16_t& learningTimeGainHours, int16_t& gatingMaxDurationMinutes,
    int16_t& stdInitial, int16_t& gainFactor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 36);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 36);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(13);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt16(vocIndexOffset);
    localError |= rxFrame.getInt16(learningTimeOffsetHours);
    localError |= rxFrame.getInt16(learningTimeGainHours);
    localError |= rxFrame.getInt16(gatingMaxDurationMinutes);
    localError |= rxFrame.getInt16(stdInitial);
    localError |= rxFrame.getInt16(gainFactor);
    return localError;
}

int16_t SensirionUartSvm4x::getNoxTuningParameters(
    int16_t& noxIndexOffset, int16_t& learningTimeOffsetHours,
    int16_t& learningTimeGainHours, int16_t& gatingMaxDurationMinutes,
    int16_t& stdInitial, int16_t& gainFactor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 36);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 36);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(14);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getInt16(noxIndexOffset);
    localError |= rxFrame.getInt16(learningTimeOffsetHours);
    localError |= rxFrame.getInt16(learningTimeGainHours);
    localError |= rxFrame.getInt16(gatingMaxDurationMinutes);
    localError |= rxFrame.getInt16(stdInitial);
    localError |= rxFrame.getInt16(gainFactor);
    return localError;
}

int16_t SensirionUartSvm4x::storeNvData() {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 12);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 12);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(128);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t
SensirionUartSvm4x::llsetTemperatureOffsetForRhtMeasurements(int16_t tOffset) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 16);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 16);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 3);
    localError |= txFrame.addUInt8(129);
    localError |= txFrame.addInt16(tOffset);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::setVocTuningParameters(
    int16_t vocIndexOffset, int16_t learningTimeOffsetHours,
    int16_t learningTimeGainHours, int16_t gatingMaxDurationMinutes,
    int16_t stdInitial, int16_t gainFactor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 36);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 36);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 13);
    localError |= txFrame.addUInt8(141);
    localError |= txFrame.addInt16(vocIndexOffset);
    localError |= txFrame.addInt16(learningTimeOffsetHours);
    localError |= txFrame.addInt16(learningTimeGainHours);
    localError |= txFrame.addInt16(gatingMaxDurationMinutes);
    localError |= txFrame.addInt16(stdInitial);
    localError |= txFrame.addInt16(gainFactor);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::setNoxTuningParameters(
    int16_t noxIndexOffset, int16_t learningTimeOffsetHours,
    int16_t learningTimeGainHours, int16_t gatingMaxDurationMinutes,
    int16_t stdInitial, int16_t gainFactor) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 36);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 36);
    localError = txFrame.begin(0x60, SVM4X_SHDLC_ADDR, 13);
    localError |= txFrame.addUInt8(142);
    localError |= txFrame.addInt16(noxIndexOffset);
    localError |= txFrame.addInt16(learningTimeOffsetHours);
    localError |= txFrame.addInt16(learningTimeGainHours);
    localError |= txFrame.addInt16(gatingMaxDurationMinutes);
    localError |= txFrame.addInt16(stdInitial);
    localError |= txFrame.addInt16(gainFactor);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::getVocState(uint8_t state[], uint16_t stateSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x61, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(8);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)state, stateSize);
    return localError;
}

int16_t SensirionUartSvm4x::getNoxState(uint8_t state[], uint16_t stateSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x61, SVM4X_SHDLC_ADDR, 1);
    localError |= txFrame.addUInt8(9);
    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    localError |= rxFrame.getBytes((uint8_t*)state, stateSize);
    return localError;
}

int16_t SensirionUartSvm4x::setVocState(const uint8_t state[],
                                        uint16_t stateSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x61, SVM4X_SHDLC_ADDR, 9);
    localError |= txFrame.addUInt8(136);
    localError |= txFrame.addBytes(state, stateSize);

    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

int16_t SensirionUartSvm4x::setNoxState(const uint8_t state[],
                                        uint16_t stateSize) {
    int16_t localError = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    SensirionShdlcTxFrame txFrame(buffer_ptr, 28);
    SensirionShdlcRxFrame rxFrame(buffer_ptr, 28);
    localError = txFrame.begin(0x61, SVM4X_SHDLC_ADDR, 9);
    localError |= txFrame.addUInt8(137);
    localError |= txFrame.addBytes(state, stateSize);

    localError |= txFrame.finish();
    if (localError) {
        return localError;
    }
    localError = SensirionShdlcCommunication::sendAndReceiveFrame(
        *_serial, txFrame, rxFrame, (uint32_t)50 * 1000);
    if (localError) {
        return localError;
    }
    return NO_ERROR;
}

void SensirionUartSvm4x::begin(Stream& serial) {
    _serial = &serial;
}
